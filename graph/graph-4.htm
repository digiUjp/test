<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4th-Multilayer Expanded Peterson Graph (Graph-4)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000510;
        }

        canvas {
            display: block;
        }

        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            pointer-events: none;
            background: rgba(0, 10, 30, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            backdrop-filter: blur(5px);
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        p {
            margin: 5px 0;
            font-size: 0.9rem;
            color: #aaaaff;
        }

        .stat {
            font-weight: bold;
            color: #fff;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>

<body>
    <div id="ui-container">
        <h1>Graph-4 (4th Layer)</h1>
        <p>Recursive Expansion Level 4</p>
        <p>Total Nodes: <span class="stat">1250</span></p>
        <p>Total Edges: <span class="stat">5625</span></p>
        <p>Clusters (L3): <span class="stat">250</span></p>
        <p>Clusters (L2): <span class="stat">50</span></p>
        <p>Super-Clusters (L1): <span class="stat">10</span></p>
    </div>

    <script>
        // --- Graph Generation Logic ---

        // 1. Define Base Graph (Graph-1) Edges
        // Nodes 0-9
        function getGraph1Edges() {
            const edges = [];
            // Inner Cycle (0-4)
            for (let i = 0; i < 5; i++) edges.push([i, (i + 1) % 5]);
            // Outer Cycle (5-9)
            for (let i = 0; i < 5; i++) edges.push([5 + i, 5 + ((i + 1) % 5)]);
            // Cross Connections
            const cross = [[5, 0], [6, 3], [7, 1], [8, 4], [9, 2]];
            edges.push(...cross);
            return edges;
        }

        // 2. Expansion Function
        function expandGraph(currentEdges, currentNodeCount) {
            const newEdges = [];
            const pattern = { 0: 0, 1: 3, 2: 1, 3: 4, 4: 2 };

            // A. Internal Edges for each new cluster
            for (let i = 0; i < currentNodeCount; i++) {
                const base = i * 5;
                for (let k = 0; k < 5; k++) {
                    newEdges.push({
                        source: base + k,
                        target: base + ((k + 1) % 5),
                        type: 'internal'
                    });
                }
            }

            // B. External Edges
            currentEdges.forEach(edge => {
                const u = edge.source !== undefined ? edge.source : edge[0];
                const v = edge.target !== undefined ? edge.target : edge[1];

                const sourceCluster = (u > v) ? u : v;
                const targetCluster = (u > v) ? v : u;

                for (let srcLocal = 0; srcLocal < 5; srcLocal++) {
                    const tgtLocal = pattern[srcLocal];
                    const globalSource = sourceCluster * 5 + srcLocal;
                    const globalTarget = targetCluster * 5 + tgtLocal;

                    newEdges.push({
                        source: globalSource,
                        target: globalTarget,
                        type: 'external'
                    });
                }
            });

            return newEdges;
        }

        // --- Generate Data ---

        // Step 1: Graph-1
        const edgesG1 = getGraph1Edges();
        const nodesG1Count = 10;

        // Step 2: Graph-2
        const edgesG2 = expandGraph(edgesG1, nodesG1Count);
        const nodesG2Count = 50;

        // Step 3: Graph-3
        const edgesG3 = expandGraph(edgesG2, nodesG2Count);
        const nodesG3Count = 250;

        // Step 4: Graph-4
        const edgesG4 = expandGraph(edgesG3, nodesG3Count);
        const nodesG4Count = 1250;

        // --- Visualization Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000510);
        scene.fog = new THREE.FogExp2(0x000510, 0.005); // Reduced fog for better visibility of deep structure

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
        camera.position.set(0, 0, 180); // Moved back slightly

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.3;

        // --- Layout Calculation ---
        const nodes = [];

        // Radii configuration (Expanded for 4 levels)
        const R1_Inner = 70;
        const R1_Outer = 110;
        const R2 = 20;  // G2 clusters
        const R3 = 5;   // G3 clusters
        const R4 = 1.2; // G4 clusters (leaf nodes)

        for (let i = 0; i < nodesG4Count; i++) {
            // Hierarchy Indices
            const parentIndex = Math.floor(i / 5);         // Index in Graph-3 (0-249)
            const grandParentIndex = Math.floor(parentIndex / 5); // Index in Graph-2 (0-49)
            const greatGrandParentIndex = Math.floor(grandParentIndex / 5); // Index in Graph-1 (0-9)

            const localIndex = i % 5;                      // 0-4 (Position in G4 cluster)
            const parentLocalIndex = parentIndex % 5;      // 0-4 (Position in G3 cluster)
            const grandParentLocalIndex = grandParentIndex % 5; // 0-4 (Position in G2 cluster)

            // 1. Great Grandparent Position (Graph-1 Layout)
            let ggpX, ggpY;
            let ggpAngle;
            if (greatGrandParentIndex < 5) {
                // Inner
                ggpAngle = (greatGrandParentIndex * 2 * Math.PI / 5) - Math.PI / 2;
                ggpX = R1_Inner * Math.cos(ggpAngle);
                ggpY = R1_Inner * Math.sin(ggpAngle);
            } else {
                // Outer
                ggpAngle = ((greatGrandParentIndex - 5) * 2 * Math.PI / 5) - Math.PI / 2;
                ggpX = R1_Outer * Math.cos(ggpAngle);
                ggpY = R1_Outer * Math.sin(ggpAngle);
            }

            // 2. Grandparent Position (Graph-2 Layout relative to GGP)
            const gpAngle = (grandParentLocalIndex * 2 * Math.PI / 5) - Math.PI / 2 + ggpAngle;
            const gpX = R2 * Math.cos(gpAngle);
            const gpY = R2 * Math.sin(gpAngle);

            // 3. Parent Position (Graph-3 Layout relative to GP)
            const pAngle = (parentLocalIndex * 2 * Math.PI / 5) - Math.PI / 2 + gpAngle;
            const pX = R3 * Math.cos(pAngle);
            const pY = R3 * Math.sin(pAngle);

            // 4. Node Position (Graph-4 Layout relative to Parent)
            const nAngle = (localIndex * 2 * Math.PI / 5) - Math.PI / 2 + pAngle;
            const nX = R4 * Math.cos(nAngle);
            const nY = R4 * Math.sin(nAngle);

            // Combine
            const vector = new THREE.Vector3(ggpX + gpX + pX + nX, ggpY + gpY + pY + nY, 0);

            // Z variation based on hierarchy
            if (greatGrandParentIndex < 5) vector.z += 15;
            else vector.z -= 15;

            // Subtle Z variation for G2
            if (grandParentIndex % 2 === 0) vector.z += 2; else vector.z -= 2;

            nodes.push(vector);
        }

        // --- Rendering ---
        const graphGroup = new THREE.Group();
        scene.add(graphGroup);

        // Materials
        const nodeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const nodeGeo = new THREE.SphereGeometry(0.2, 6, 6); // Smaller nodes

        // Batch Nodes
        const instancedMesh = new THREE.InstancedMesh(nodeGeo, nodeMat, nodesG4Count);
        const dummy = new THREE.Object3D();

        nodes.forEach((pos, idx) => {
            dummy.position.copy(pos);
            dummy.updateMatrix();
            instancedMesh.setMatrixAt(idx, dummy.matrix);
        });
        graphGroup.add(instancedMesh);

        // Edges
        const internalEdges = [];
        const externalEdges = [];

        edgesG4.forEach(e => {
            const p1 = nodes[e.source];
            const p2 = nodes[e.target];
            const arr = [p1.x, p1.y, p1.z, p2.x, p2.y, p2.z];

            if (e.type === 'internal') {
                internalEdges.push(...arr);
            } else {
                externalEdges.push(...arr);
            }
        });

        const intGeo = new THREE.BufferGeometry();
        intGeo.setAttribute('position', new THREE.Float32BufferAttribute(internalEdges, 3));
        const intMat = new THREE.LineBasicMaterial({ color: 0xff00ff, opacity: 0.6, transparent: true });
        const intLines = new THREE.LineSegments(intGeo, intMat);
        graphGroup.add(intLines);

        const extGeo = new THREE.BufferGeometry();
        extGeo.setAttribute('position', new THREE.Float32BufferAttribute(externalEdges, 3));
        const extMat = new THREE.LineBasicMaterial({ color: 0x4444ff, opacity: 0.2, transparent: true });
        const extLines = new THREE.LineSegments(extGeo, extMat);
        graphGroup.add(extLines);

        // Add "Ghost" structures for L2 and L3 to help visualize hierarchy
        // L3 Rings (Parent Clusters)
        for (let i = 0; i < nodesG3Count; i++) {
            // Re-calculate center of this L3 cluster
            const pIdx = i; // Index in G3
            const gpIdx = Math.floor(pIdx / 5); // Index in G2
            const ggpIdx = Math.floor(gpIdx / 5); // Index in G1

            const pLocal = pIdx % 5;
            const gpLocal = gpIdx % 5;

            // GGP
            let ggpAngle, cx, cy;
            if (ggpIdx < 5) {
                ggpAngle = (ggpIdx * 2 * Math.PI / 5) - Math.PI / 2;
                cx = R1_Inner * Math.cos(ggpAngle);
                cy = R1_Inner * Math.sin(ggpAngle);
            } else {
                ggpAngle = ((ggpIdx - 5) * 2 * Math.PI / 5) - Math.PI / 2;
                cx = R1_Outer * Math.cos(ggpAngle);
                cy = R1_Outer * Math.sin(ggpAngle);
            }

            // GP
            const gpAngle = (gpLocal * 2 * Math.PI / 5) - Math.PI / 2 + ggpAngle;
            const gpx = cx + R2 * Math.cos(gpAngle);
            const gpy = cy + R2 * Math.sin(gpAngle);

            // P
            const pAngle = (pLocal * 2 * Math.PI / 5) - Math.PI / 2 + gpAngle;
            const px = gpx + R3 * Math.cos(pAngle);
            const py = gpy + R3 * Math.sin(pAngle);

            let pz = (ggpIdx < 5) ? 15 : -15;
            if (gpIdx % 2 === 0) pz += 2; else pz -= 2;

            const ring = new THREE.Mesh(
                new THREE.RingGeometry(R4 * 0.8, R4 * 0.9, 12),
                new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.15, transparent: true, side: THREE.DoubleSide })
            );
            ring.position.set(px, py, pz);
            graphGroup.add(ring);
        }

        // Particle System for Ambiance
        const particlesGeo = new THREE.BufferGeometry();
        const pCount = 5000;
        const pPos = new Float32Array(pCount * 3);
        for (let i = 0; i < pCount * 3; i++) pPos[i] = (Math.random() - 0.5) * 400;
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        const pMat = new THREE.PointsMaterial({ size: 0.5, color: 0x8888ff, transparent: true, opacity: 0.4 });
        const particles = new THREE.Points(particlesGeo, pMat);
        scene.add(particles);

        // Animation
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const time = Date.now() * 0.0005;
            graphGroup.rotation.z = Math.sin(time * 0.1) * 0.05;
            graphGroup.rotation.y = Math.sin(time * 0.05) * 0.02;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>
