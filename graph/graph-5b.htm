<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5th-Multilayer Expanded Peterson Graph (Graph-5b) - Decentralized</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000510;
        }

        canvas {
            display: block;
        }

        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            pointer-events: none;
            background: rgba(0, 10, 30, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            backdrop-filter: blur(5px);
            z-index: 10;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        p {
            margin: 5px 0;
            font-size: 0.9rem;
            color: #aaaaff;
        }

        .stat {
            font-weight: bold;
            color: #fff;
        }

        .label {
            color: #ffffff;
            font-family: sans-serif;
            font-size: 12px;
            padding: 2px 5px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 4px;
            pointer-events: none;
            text-shadow: 0 0 2px black;
        }

        .label-l1 {
            font-size: 16px;
            font-weight: bold;
            color: #ffcc00;
            border: 1px solid #ffcc00;
        }

        .label-l2 {
            font-size: 10px;
            color: #00ccff;
            opacity: 0.8;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
</head>

<body>
    <div id="ui-container">
        <h1>Graph-5b (Decentralized)</h1>
        <p>Recursive Expansion Level 5</p>
        <p>Total Nodes: <span class="stat">6250</span></p>
        <p>Total Edges: <span class="stat">34375</span></p>
        <p>Visualization: <span class="stat">Decentralized & Interactive</span></p>
        <p style="font-size: 0.8rem; color: #888;">Left Click: Rotate | Right Click: Pan | Scroll: Zoom</p>
    </div>

    <script>
        // --- Graph Generation Logic ---

        // 1. Define Base Graph (Graph-1) Edges
        function getGraph1Edges() {
            const edges = [];
            for (let i = 0; i < 5; i++) edges.push([i, (i + 1) % 5]);
            for (let i = 0; i < 5; i++) edges.push([5 + i, 5 + ((i + 1) % 5)]);
            const cross = [[5, 0], [6, 3], [7, 1], [8, 4], [9, 2]];
            edges.push(...cross);
            return edges;
        }

        // 2. Expansion Function
        function expandGraph(currentEdges, currentNodeCount) {
            const newEdges = [];
            const pattern = { 0: 0, 1: 3, 2: 1, 3: 4, 4: 2 };

            // A. Internal Edges
            for (let i = 0; i < currentNodeCount; i++) {
                const base = i * 5;
                for (let k = 0; k < 5; k++) {
                    newEdges.push({
                        source: base + k,
                        target: base + ((k + 1) % 5),
                        type: 'internal',
                        hierarchy: 0 // Lowest level
                    });
                }
            }

            // B. External Edges
            currentEdges.forEach(edge => {
                const u = edge.source !== undefined ? edge.source : edge[0];
                const v = edge.target !== undefined ? edge.target : edge[1];

                const prevType = edge.type || 'base';
                let hierarchy = 1;
                if (prevType === 'external') hierarchy = (edge.hierarchy || 1) + 1;
                if (prevType === 'base') hierarchy = 4; // Top level connections

                const sourceCluster = (u > v) ? u : v;
                const targetCluster = (u > v) ? v : u;

                for (let srcLocal = 0; srcLocal < 5; srcLocal++) {
                    const tgtLocal = pattern[srcLocal];
                    const globalSource = sourceCluster * 5 + srcLocal;
                    const globalTarget = targetCluster * 5 + tgtLocal;

                    newEdges.push({
                        source: globalSource,
                        target: globalTarget,
                        type: 'external',
                        hierarchy: hierarchy
                    });
                }
            });

            return newEdges;
        }

        // --- Generate Data ---
        const edgesG1 = getGraph1Edges();
        const nodesG1Count = 10;

        const edgesG2 = expandGraph(edgesG1, nodesG1Count);
        const nodesG2Count = 50;

        const edgesG3 = expandGraph(edgesG2, nodesG2Count);
        const nodesG3Count = 250;

        const edgesG4 = expandGraph(edgesG3, nodesG3Count);
        const nodesG4Count = 1250;

        const edgesG5 = expandGraph(edgesG4, nodesG4Count);
        const nodesG5Count = 6250;

        // --- Visualization Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000510);
        scene.fog = new THREE.FogExp2(0x000510, 0.001); // Less fog for larger scale

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 0, 600); // Moved back significantly

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const labelRenderer = new THREE.CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = false; // Disable auto-rotate to let user explore easier
        controls.enablePan = true;
        controls.enableZoom = true;
        controls.minDistance = 10;
        controls.maxDistance = 2000;

        // --- Layout Calculation ---
        const nodes = [];

        // Radii - Significantly Expanded for Decentralization
        const R1_Inner = 250;
        const R1_Outer = 400;
        const R2 = 80;
        const R3 = 20;
        const R4 = 5;
        const R5 = 1.2;

        // Store cluster centers for curve control points
        const clusterCentersL1 = [];

        for (let i = 0; i < nodesG5Count; i++) {
            const parentIndex = Math.floor(i / 5);
            const grandParentIndex = Math.floor(parentIndex / 5);
            const greatGrandParentIndex = Math.floor(grandParentIndex / 5);
            const greatGreatGrandParentIndex = Math.floor(greatGrandParentIndex / 5);

            const localIndex = i % 5;
            const parentLocalIndex = parentIndex % 5;
            const grandParentLocalIndex = grandParentIndex % 5;
            const greatGrandParentLocalIndex = greatGrandParentIndex % 5;

            // L1 (GGGP)
            let gggpX, gggpY, gggpAngle;
            if (greatGreatGrandParentIndex < 5) {
                gggpAngle = (greatGreatGrandParentIndex * 2 * Math.PI / 5) - Math.PI / 2;
                gggpX = R1_Inner * Math.cos(gggpAngle);
                gggpY = R1_Inner * Math.sin(gggpAngle);
            } else {
                gggpAngle = ((greatGreatGrandParentIndex - 5) * 2 * Math.PI / 5) - Math.PI / 2;
                gggpX = R1_Outer * Math.cos(gggpAngle);
                gggpY = R1_Outer * Math.sin(gggpAngle);
            }

            // L2 (GGP)
            const ggpAngle = (greatGrandParentLocalIndex * 2 * Math.PI / 5) - Math.PI / 2 + gggpAngle;
            const ggpX = R2 * Math.cos(ggpAngle);
            const ggpY = R2 * Math.sin(ggpAngle);

            // L3 (GP)
            const gpAngle = (grandParentLocalIndex * 2 * Math.PI / 5) - Math.PI / 2 + ggpAngle;
            const gpX = R3 * Math.cos(gpAngle);
            const gpY = R3 * Math.sin(gpAngle);

            // L4 (P)
            const pAngle = (parentLocalIndex * 2 * Math.PI / 5) - Math.PI / 2 + gpAngle;
            const pX = R4 * Math.cos(pAngle);
            const pY = R4 * Math.sin(pAngle);

            // L5 (Node)
            const nAngle = (localIndex * 2 * Math.PI / 5) - Math.PI / 2 + pAngle;
            const nX = R5 * Math.cos(nAngle);
            const nY = R5 * Math.sin(nAngle);

            // Z Calculation - Increased spread
            let z = 0;
            if (greatGreatGrandParentIndex < 5) z += 50; else z -= 50;
            if (greatGrandParentIndex % 2 === 0) z += 15; else z -= 15;
            if (grandParentIndex % 2 === 0) z += 5; else z -= 5;

            const vector = new THREE.Vector3(
                gggpX + ggpX + gpX + pX + nX,
                gggpY + ggpY + gpY + pY + nY,
                z
            );
            nodes.push(vector);

            if (i % 625 === 0) {
                clusterCentersL1[greatGreatGrandParentIndex] = new THREE.Vector3(gggpX, gggpY, (greatGreatGrandParentIndex < 5) ? 50 : -50);
            }
        }

        // --- Rendering Nodes ---
        const graphGroup = new THREE.Group();
        scene.add(graphGroup);

        const nodeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const nodeGeo = new THREE.SphereGeometry(0.3, 5, 5);
        const instancedMesh = new THREE.InstancedMesh(nodeGeo, nodeMat, nodesG5Count);
        const dummy = new THREE.Object3D();

        nodes.forEach((pos, idx) => {
            dummy.position.copy(pos);
            dummy.updateMatrix();
            instancedMesh.setMatrixAt(idx, dummy.matrix);
        });
        graphGroup.add(instancedMesh);

        // --- Rendering Curved Edges ---
        const curvePositions = [];
        const curveColors = [];

        function getCenter(v1, v2) {
            return new THREE.Vector3().addVectors(v1, v2).multiplyScalar(0.5);
        }

        edgesG5.forEach(e => {
            const p1 = nodes[e.source];
            const p2 = nodes[e.target];

            if (e.type === 'internal') {
                curvePositions.push(p1.x, p1.y, p1.z);
                curvePositions.push(p2.x, p2.y, p2.z);
                curveColors.push(1, 0, 1);
                curveColors.push(1, 0, 1);
            } else {
                const mid = getCenter(p1, p2);
                const dist = p1.distanceTo(p2);
                const control = mid.clone();

                // More exaggerated curves for decentralized look
                if (dist > 50) {
                    // Very long edges (between super clusters)
                    // Push them out significantly from the center to create "arcs" around the void
                    // Calculate vector from center (0,0,0) to mid
                    const fromCenter = mid.clone().normalize();
                    control.add(fromCenter.multiplyScalar(dist * 0.5)); // Push out
                    control.z += (Math.random() - 0.5) * 40; // Random Z height
                } else if (dist > 15) {
                    // Medium edges
                    control.z += 15;
                } else {
                    // Short edges
                    control.z += 3;
                }

                const curve = new THREE.QuadraticBezierCurve3(p1, control, p2);
                const points = curve.getPoints(12); // Smoother curves

                for (let i = 0; i < points.length - 1; i++) {
                    curvePositions.push(points[i].x, points[i].y, points[i].z);
                    curvePositions.push(points[i + 1].x, points[i + 1].y, points[i + 1].z);

                    // Distance based coloring
                    if (dist > 50) {
                        curveColors.push(0.8, 0.8, 0.2); // Yellowish for long jumps
                        curveColors.push(0.8, 0.8, 0.2);
                    } else {
                        curveColors.push(0.2, 0.4, 1); // Blueish
                        curveColors.push(0.2, 0.4, 1);
                    }
                }
            }
        });

        const edgeGeo = new THREE.BufferGeometry();
        edgeGeo.setAttribute('position', new THREE.Float32BufferAttribute(curvePositions, 3));
        edgeGeo.setAttribute('color', new THREE.Float32BufferAttribute(curveColors, 3));

        const edgeMat = new THREE.LineBasicMaterial({ vertexColors: true, opacity: 0.3, transparent: true });
        const edgesMesh = new THREE.LineSegments(edgeGeo, edgeMat);
        graphGroup.add(edgesMesh);


        // --- Labels ---
        const l1Labels = [
            "Cluster 0", "Cluster 1", "Cluster 2", "Cluster 3", "Cluster 4",
            "Cluster 5", "Cluster 6", "Cluster 7", "Cluster 8", "Cluster 9"
        ];

        clusterCentersL1.forEach((center, i) => {
            if (!center) return;
            const div = document.createElement('div');
            div.className = 'label label-l1';
            div.textContent = l1Labels[i];
            const label = new THREE.CSS2DObject(div);
            label.position.copy(center);
            label.position.y += 30;
            graphGroup.add(label);
        });

        // --- Animation ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            labelRenderer.render(scene, camera);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>
